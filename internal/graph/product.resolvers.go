package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.26

import (
	"context"
	"sync"

	"github.com/krobus00/nexus-service/internal/graph/model"
	"github.com/krobus00/product-service/pb/product"
	"github.com/krobus00/storage-service/pb/storage"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.CreateProduct) (*model.Product, error) {
	userID := getUserIDFromCtx(ctx)

	product, err := r.productClient.Create(ctx, &product.CreateProductRequest{
		UserId:      userID,
		Name:        input.Name,
		Description: input.Description,
		Price:       float32(input.Price),
		ThumbnailId: input.ThumbnailID,
	})

	e, ok := status.FromError(err)
	if !ok {
		return nil, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return nil, gqlerror.Errorf(e.Message())
	default:
		return nil, model.ErrInternal
	}

	return &model.Product{
		ID:          product.GetId(),
		Name:        product.GetName(),
		Description: product.GetDescription(),
		Price:       float64(product.GetPrice()),
		OwnerID:     product.GetOwnerId(),
		ThumbnailID: product.GetThumbnailId(),
		CreatedAt:   product.GetCreatedAt(),
		UpdatedAt:   product.GetUpdatedAt(),
		DeletedAt:   product.GetDeletedAt(),
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input model.UpdateProduct) (*model.Product, error) {
	userID := getUserIDFromCtx(ctx)

	product, err := r.productClient.Update(ctx, &product.UpdateProductRequest{
		UserId:      userID,
		Id:          input.ID,
		Name:        input.Name,
		Description: input.Description,
		Price:       float32(input.Price),
		ThumbnailId: input.ThumbnailID,
	})

	e, ok := status.FromError(err)
	if !ok {
		return nil, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return nil, gqlerror.Errorf(e.Message())
	default:
		return nil, model.ErrInternal
	}

	return &model.Product{
		ID:          product.GetId(),
		Name:        product.GetName(),
		Description: product.GetDescription(),
		Price:       float64(product.GetPrice()),
		OwnerID:     product.GetOwnerId(),
		ThumbnailID: product.GetThumbnailId(),
		CreatedAt:   product.GetCreatedAt(),
		UpdatedAt:   product.GetUpdatedAt(),
		DeletedAt:   product.GetDeletedAt(),
	}, nil
}

// DeleteProductByID is the resolver for the deleteProductByID field.
func (r *mutationResolver) DeleteProductByID(ctx context.Context, id string) (bool, error) {
	userID := getUserIDFromCtx(ctx)

	_, err := r.productClient.Delete(ctx, &product.DeleteProductRequest{
		UserId: userID,
		Id:     id,
	})

	e, ok := status.FromError(err)
	if !ok {
		return false, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return false, gqlerror.Errorf(e.Message())
	default:
		return false, model.ErrInternal
	}

	return true, nil
}

// Thumbnail is the resolver for the thumbnail field.
func (r *productResolver) Thumbnail(ctx context.Context, obj *model.Product) (*model.Object, error) {
	userID := getUserIDFromCtx(ctx)

	object, err := r.storageClient.GetObjectByID(ctx, &storage.GetObjectByIDRequest{
		UserId:   userID,
		ObjectId: obj.ThumbnailID,
	})

	e, ok := status.FromError(err)
	if !ok {
		return nil, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return nil, gqlerror.Errorf(e.Message())
	default:
		return nil, model.ErrInternal
	}

	return &model.Object{
		ID:         object.GetId(),
		FileName:   object.GetFileName(),
		Type:       object.GetType(),
		SignedURL:  object.GetSignedUrl(),
		ExpiredAt:  object.GetExpiredAt(),
		IsPublic:   object.GetIsPublic(),
		UploadedBy: object.GetUploadedBy(),
		CreatedAt:  object.GetCreatedAt(),
	}, nil
}

// FindProductByID is the resolver for the findProductByID field.
func (r *queryResolver) FindProductByID(ctx context.Context, id string) (*model.Product, error) {
	userID := getUserIDFromCtx(ctx)

	product, err := r.productClient.FindByID(ctx, &product.FindByIDRequest{
		UserId: userID,
		Id:     id,
	})

	e, ok := status.FromError(err)
	if !ok {
		return nil, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return nil, gqlerror.Errorf(e.Message())
	default:
		return nil, model.ErrInternal
	}

	return &model.Product{
		ID:          product.GetId(),
		Name:        product.GetName(),
		Description: product.GetDescription(),
		Price:       float64(product.GetPrice()),
		OwnerID:     product.GetOwnerId(),
		ThumbnailID: product.GetThumbnailId(),
		CreatedAt:   product.GetCreatedAt(),
		UpdatedAt:   product.GetUpdatedAt(),
		DeletedAt:   product.GetDeletedAt(),
	}, nil
}

// FindProducts is the resolver for the findProducts field.
func (r *queryResolver) FindProducts(ctx context.Context, input *model.PaginationRequest) (*model.ProductPaginationResponse, error) {
	userID := getUserIDFromCtx(ctx)
	results := make([]*model.Product, 0)

	res, err := r.productClient.FindPaginatedIDs(ctx, &product.PaginationRequest{
		UserId:         userID,
		Search:         input.Search,
		Sort:           input.Sort,
		Limit:          int64(input.Limit),
		Page:           int64(input.Page),
		IncludeDeleted: input.IncludeDeleted,
	})

	e, ok := status.FromError(err)
	if !ok {
		return nil, model.ErrInternal
	}

	switch e.Code() {
	case codes.OK:
	case codes.FailedPrecondition, codes.NotFound, codes.Unauthenticated:
		return nil, gqlerror.Errorf(e.Message())
	default:
		return nil, model.ErrInternal
	}

	meta := &model.PaginationMeta{
		Search:  res.Meta.GetSearch(),
		Sort:    res.Meta.GetSort(),
		Limit:   int(res.Meta.GetLimit()),
		Page:    int(res.Meta.GetPage()),
		Count:   int(res.GetCount()),
		MaxPage: int(res.GetMaxPage()),
	}

	productMap := map[string]*model.Product{}
	productMapMu := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(len(res.GetItems()))

	for _, productID := range res.GetItems() {
		go func(id string) {
			defer wg.Done()
			product, err := r.productClient.FindByID(ctx, &product.FindByIDRequest{
				UserId: userID,
				Id:     id,
			})
			if err == nil {
				productMapMu.Lock()
				productMap[id] = &model.Product{
					ID:          product.GetId(),
					Name:        product.GetName(),
					Description: product.GetDescription(),
					Price:       float64(product.GetPrice()),
					ThumbnailID: product.GetThumbnailId(),
					OwnerID:     product.GetOwnerId(),
					CreatedAt:   product.GetCreatedAt(),
					UpdatedAt:   product.GetUpdatedAt(),
					DeletedAt:   product.GetDeletedAt(),
				}
				productMapMu.Unlock()
			}

		}(productID)
	}

	wg.Wait()

	for _, productID := range res.GetItems() {
		if product, ok := productMap[productID]; ok {
			results = append(results, product)
		}
	}

	return &model.ProductPaginationResponse{
		Meta:  meta,
		Items: results,
	}, nil
}

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

type productResolver struct{ *Resolver }
